import { OutputTargetDocsReadme } from "@stencil/core/internal";
import { config } from "../stencil.config.js";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import remarkFrontmatter from "remark-frontmatter";
import remarkParse from "remark-parse";
import remarkStringify from "remark-stringify";
import { unified } from "unified";
import { CONTINUE, SKIP, visit } from "unist-util-visit";
import yaml from "js-yaml";
import { RootContent } from "mdast";

interface UsageFrontmatter {
  title?: string;
  position?: number;
}

interface UsageSection {
  title: string;
  position: number;
  content: RootContent[];
}

const PROJECT_ROOT = new URL("..", import.meta.url);

/**
 * Update the usage sections in the readme files produced by the docs-readme output target.
 *
 * The Usage section of the readme file is generated by the markdown files in the component's
 * `usage` subdirectory[^1]. By default, the order and title of the Usage subsections is determined
 * by the name of the markdown files. In order to allow for more flexibility, this function replaces
 * the content of the Usage section, setting the subsection titles and order based on the
 * frontmatter of the markdown files. The following frontmatter properties are supported:
 *
 * - `title`: The title of the subsection within the Usage section. If not specified, the title is
 *   derived from the filename.
 * - `position`: The position of the subsection within the Usage section. If not specified, the
 *   subsection is placed after all subsection that have a position specified. If two or more
 *   subsections have the same position, they are sorted by title.
 *
 * [^1]: https://stenciljs.com/docs/v4.10/docs-readme#usage-examples
 */
async function updateReadmeDocsUsageSections() {
  // Parser and stringifier objects for processing Markdown files
  const parser = unified().use(remarkParse).use(remarkFrontmatter);
  const stringifier = unified().use(remarkStringify);

  // Get the directories that contain the readme files produced by the docs-readme output target.
  // The file structure produced by the output target is: {dir}/{component}/readme.md.
  const readmeConfig = config.outputTargets.find(
    (ot) => ot.type === "docs-readme",
  ) as OutputTargetDocsReadme;
  const componentsDir = path.resolve(
    PROJECT_ROOT.pathname,
    readmeConfig.dir,
    "components",
  );
  const dirContent = await fs.readdir(componentsDir, { withFileTypes: true });

  for (const dirent of dirContent) {
    if (!dirent.isDirectory()) {
      // Skip non-directory entries. This could be the _category_.json file used by Docusaurus.
      continue;
    }
    // The path to the readme.md file for this component
    const readmePath = path.resolve(
      dirent.parentPath,
      dirent.name,
      "readme.md",
    );
    // The path to the usage directory for this component
    const srcUsagePath = path.resolve(
      PROJECT_ROOT.pathname,
      "src/components",
      dirent.name,
      "usage",
    );
    // Try to read the usage directory. If it doesn't exist, skip this component.
    let srcUsageContent = [];
    try {
      srcUsageContent = await fs.readdir(srcUsagePath);
    } catch (err) {
      if (
        Object.prototype.hasOwnProperty.call(err, "code") &&
        err.code === "ENOENT"
      ) {
        continue;
      }
      throw err;
    }

    // For each of the files in the usage directory, read the file and parse the frontmatter. The
    // frontmatter should contain a title and a position, but use sensible defaults if they are not
    // present. Once the frontmatter is parsed, remove it from the content.
    const usages: UsageSection[] = [];
    for (const file of srcUsageContent) {
      const filePath = path.resolve(srcUsagePath, file);
      const fileContent = await fs.readFile(filePath, "utf-8");
      const tree = parser.parse(fileContent);
      const usage = {
        title: path.basename(file, ".md"),
        position: Infinity,
        content: tree.children,
      };
      visit(tree, "yaml", (node, index, parent) => {
        if (typeof index !== "number" || !parent) {
          return;
        }
        const frontmatter = yaml.load(node.value) as UsageFrontmatter;
        if (frontmatter.title !== undefined) {
          usage.title = frontmatter.title;
        }
        if (frontmatter.position !== undefined) {
          usage.position = frontmatter.position;
        }
        parent.children.splice(index, 1);
        return SKIP;
      });
      usages.push(usage);
    }
    // Sort the usages by position and then by title.
    usages.sort((a, b) => {
      const positionDiff = a.position - b.position;
      if (positionDiff !== 0) {
        return positionDiff;
      }
      return a.title.localeCompare(b.title);
    });
    // Generate new markdown AST nodes for the usage sections. The first node is a heading with the
    // title and the rest are the content of the usage file.
    const newUsageSections: RootContent[] = usages.flatMap((usage) => [
      {
        type: "heading",
        depth: 3,
        children: [
          {
            type: "text",
            value: usage.title,
          },
        ],
      },
      ...usage.content,
    ]);

    // Open the readme file produced by the docs-readme output target and parse it. Find the Usage
    // section and replace the content below it with the new usage sections.
    const readmeContent = await fs.readFile(readmePath, "utf-8");
    const tree = parser.parse(readmeContent);
    let inTargetSection = false;
    let startIndex = null;
    visit(tree, "heading", (node, index, parent) => {
      if (node.depth === 2) {
        if (
          node.children[0].type === "text" &&
          node.children[0].value === "Usage"
        ) {
          // We have found the Usage section, note its index for later
          inTargetSection = true;
          startIndex = index;
        } else if (inTargetSection) {
          // We have found another level 2 header after the Usage one. But don't get fooled by the
          // "fake" ones that are actually there because docs-readme doesn't understand frontmatter.
          // These are distinguished by the fact that they are preceded by a thematic break. Once we
          // have found the "real" next level 2 header, replace all the content from just after the
          // startIndex to the current index with the new usage sections.
          if (parent.children[index - 1].type === "thematicBreak") {
            return CONTINUE;
          }
          inTargetSection = false;
          parent.children.splice(
            startIndex + 1,
            index - startIndex - 1,
            ...newUsageSections,
          );
          return SKIP;
        }
      }
      return CONTINUE;
    });

    // Handle the case where the Usage section is the last one in the file.
    if (inTargetSection && startIndex !== null) {
      const parent = tree.children;
      parent.splice(
        startIndex + 1,
        parent.length - startIndex - 1,
        ...newUsageSections,
      );
    }

    // Remove extraneous thematic breaks that are left over from the docs-readme output target.
    visit(tree, "thematicBreak", (_, index, parent) => {
      if (typeof index !== "number" || !parent) {
        return;
      }
      parent.children.splice(index, 1);
      return SKIP;
    });

    // Write the updated readme file back to disk.
    console.log("Updated usage sections:", dirent.name);
    await fs.writeFile(readmePath, stringifier.stringify(tree));
  }
}

/**
 * Run all the post-build steps.
 */
async function main() {
  await updateReadmeDocsUsageSections();
}

main()
  .then(() => {
    console.log("Post-build script completed successfully.");
  })
  .catch((err) => {
    console.error("Error running post-build script:", err);
    process.exit(1);
  });
