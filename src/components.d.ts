/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IRibbonGroup, IRibbonModel, IRibbonSubject } from "./globals/models";
import { Cam } from "./globals/@noctua.form";
export { IRibbonGroup, IRibbonModel, IRibbonSubject } from "./globals/models";
export { Cam } from "./globals/@noctua.form";
export namespace Components {
    interface GoAnnotationRibbon {
        /**
          * add a cell at the beginning of each row/subject to show all annotations
         */
        "addCellAll": boolean;
        "annotationLabels": string;
        "baseApiUrl": string;
        /**
          * false = show a gradient of colors to indicate the value of a cell true = show only two colors (minColor; maxColor) to indicate the values of a cell
         */
        "binaryColor": boolean;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryAllStyle": number;
        /**
          * Override of the category case 0 (default) = unchanged 1 = to lower case 2 = to upper case
         */
        "categoryCase": number;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryOtherStyle": number;
        "classLabels": string;
        /**
          * Which value to base the cell color on 0 = class count 1 = annotation count
         */
        "colorBy": number;
        /**
          * if provided, will override any value provided in subjects and subset
         */
        "data": string;
        "excludePB": boolean;
        /**
          * Filter rows based on the presence of one or more values in a given column The filtering will be based on cell label or id Example: filter-by="evidence:ISS,ISO or multi-step filters: filter-by:evidence:ISS,ISO;term:xxx" Note: if value is "", remove any filtering
         */
        "filterBy": string;
        "filterCrossAspect": boolean;
        "filterReference": string;
        /**
          * If true, the ribbon will fire an event if a user click an empty cell If false, the ribbon will not fire the event on an empty cell Note: if selectionMode == SELECTION.COLUMN, then the event will trigger if at least one of the selected cells has annotations
         */
        "fireEventOnEmptyCells": boolean;
        "groupBaseUrl": string;
        /**
          * Using this parameter, the table rows can bee grouped based on column ids A multiple step grouping is possible by using a ";" between groups The grouping applies before the ordering Example: hid-1,hid-3 OR hid-1,hid-3;hid-2 Note: if value is "", remove any grouping
         */
        "groupBy": string;
        "groupClickable": boolean;
        "groupMaxLabelSize": number;
        "groupNewTab": boolean;
        /**
          * Used to hide specific column of the table
         */
        "hideColumns": string;
        "maxColor": string;
        "maxHeatLevel": number;
        "minColor": string;
        /**
          * This is used to sort the table depending of a column The column cells must be single values The ordering applies after the grouping Note: if value is "", remove any ordering
         */
        "orderBy": string;
        /**
          * If no value is provided, the ribbon will load without any group selected. If a value is provided, the ribbon will show the requested group as selected The value should be the id of the group to be selected
         */
        "selected": any;
        /**
          * Click handling of a cell. 0 = select only the cell (1 subject, 1 group) 1 = select the whole column (all subjects, 1 group)
         */
        "selectionMode": number;
        /**
          * add a cell at the end of each row/subject to represent all annotations not mapped to a specific term
         */
        "showOtherGroup": boolean;
        "subjectBaseUrl": string;
        "subjectOpenNewTab": boolean;
        /**
          * Position the subject label of each row 0 = None 1 = Left 2 = Right 3 = Bottom
         */
        "subjectPosition": number;
        "subjectUseTaxonIcon": boolean;
        /**
          * provide gene ids (e.g. RGD:620474,RGD:3889 or as a list ["RGD:620474", "RGD:3889"])
         */
        "subjects": string;
        "subset": string;
    }
    interface GoAnnotationRibbonCell {
        "annotationLabels": string;
        /**
          * If set to true, won't show any color and can not be hovered or selected This is used for group that can not have annotation for a given subject
         */
        "available": boolean;
        "binaryColor": boolean;
        "classLabels": string;
        "colorBy": number;
        "group": IRibbonGroup;
        "hovered": boolean;
        "maxColor": string;
        "maxHeatLevel": number;
        "minColor": string;
        "selected": boolean;
        "subject": IRibbonSubject;
    }
    interface GoAnnotationRibbonStrips {
        /**
          * add a cell at the beginning of each row/subject to show all annotations
         */
        "addCellAll": boolean;
        "annotationLabels": string;
        "baseApiUrl": string;
        /**
          * false = show a gradient of colors to indicate the value of a cell true = show only two colors (minColor; maxColor) to indicate the values of a cell
         */
        "binaryColor": boolean;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryAllStyle": number;
        /**
          * Override of the category case 0 (default) = unchanged 1 = to lower case 2 = to upper case
         */
        "categoryCase": number;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryOtherStyle": number;
        "classLabels": string;
        /**
          * Which value to base the cell color on 0 = class count 1 = annotation count
         */
        "colorBy": number;
        /**
          * if provided, will override any value provided in subjects and subset
         */
        "data": string;
        /**
          * If true, the ribbon will fire an event if a user click an empty cell If false, the ribbon will not fire the event on an empty cell Note: if selectionMode == SELECTION.COLUMN, then the event will trigger if at least one of the selected cells has annotations
         */
        "fireEventOnEmptyCells": boolean;
        "groupBaseUrl": string;
        "groupClickable": boolean;
        "groupMaxLabelSize": number;
        "groupNewTab": boolean;
        "maxColor": string;
        "maxHeatLevel": number;
        "minColor": string;
        "ribbonSummary": IRibbonModel;
        "selectGroup": (group_id: any) => Promise<void>;
        /**
          * If no value is provided, the ribbon will load without any group selected. If a value is provided, the ribbon will show the requested group as selected The value should be the id of the group to be selected
         */
        "selected": any;
        /**
          * Click handling of a cell. 0 = select only the cell (1 subject, 1 group) 1 = select the whole column (all subjects, 1 group)
         */
        "selectionMode": number;
        "showOtherGroup": boolean;
        "subjectBaseUrl": string;
        "subjectOpenNewTab": boolean;
        /**
          * Position the subject label of each row 0 = None 1 = Left 2 = Right 3 = Bottom
         */
        "subjectPosition": number;
        "subjectUseTaxonIcon": boolean;
        /**
          * provide gene ids (e.g. RGD:620474,RGD:3889 or as a list ["RGD:620474", "RGD:3889"])
         */
        "subjects": string;
        "subset": string;
        /**
          * When this is set to false, changing the subjects Prop won't trigger the reload of the ribbon This is necessary when the ribbon is showing data other than GO or not using the internal fetchData mechanism
         */
        "updateOnSubjectChange": boolean;
    }
    interface GoAnnotationRibbonSubject {
        "newTab": boolean;
        "subject": IRibbonSubject;
        "subjectBaseURL": string;
    }
    interface GoAnnotationRibbonTable {
        "baseApiUrl": string;
        /**
          * Reading biolink data. This will trigger a render of the table as would changing data
         */
        "bioLinkData": string;
        /**
          * Must follow the appropriate JSON data model Can be given as either JSON or stringified JSON
         */
        "data": string;
        /**
          * Filter rows based on the presence of one or more values in a given column The filtering will be based on cell label or id Example: filter-by="evidence:ISS,ISO or multi-step filters: filter-by:evidence:ISS,ISO;term:xxx" Note: if value is "", remove any filtering
         */
        "filterBy": string;
        "groupBaseUrl": string;
        /**
          * Using this parameter, the table rows can bee grouped based on column ids A multiple step grouping is possible by using a ";" between groups The grouping applies before the ordering Example: hid-1,hid-3 OR hid-1,hid-3;hid-2 Note: if value is "", remove any grouping
         */
        "groupBy": string;
        /**
          * Used to hide specific column of the table
         */
        "hideColumns": string;
        /**
          * This is used to sort the table depending of a column The column cells must be single values The ordering applies after the grouping Note: if value is "", remove any ordering
         */
        "orderBy": string;
        "showCurie": () => Promise<void>;
        "showDBXrefs": () => Promise<void>;
        "showOriginalTable": () => Promise<void>;
        "showTable": () => Promise<void>;
        "subjectBaseUrl": string;
    }
    interface GoEntityAutocomplete {
        /**
          * Category to constrain the search; by default search "gene" Other values accepted: `undefined` : search both terms and genes `gene` : will only search genes used in GO `biological%20process` : will search for GO BP terms `molecular%20function` : will search for GO MF terms `cellular%20component` : will search for GO CC terms `cellular%20component,molecular%20function,biological%20process` : will search any GO term
         */
        "category": string;
        /**
          * Maximum number of results to show
         */
        "maxResults": number;
        /**
          * Default placeholder for the autocomplete
         */
        "placeholder": string;
        "value": string;
    }
    interface GoGocamViewer {
        /**
          * The url used to fetch GO-CAM graphs. Any occurrence of %ID in the string will be replaced by the GO-CAM ID.
         */
        "apiUrl": string;
        /**
          * ID of the GO-CAM to be shown in this widget. If provided, the GO-CAM will automatically be fetched using this ID and the value of the `api-url` prop. If omitted, data will not automatically be fetched, but can be provided via the `setModelData` method. This may be useful if the host page already has the GO-CAM data.
         */
        "gocamId": string;
        /**
          * Center the cytoscape graph to fit the whole graph
         */
        "resetView": () => Promise<void>;
        /**
          * Define if the GO-CAM viz should capture the mouse scroll
          * @param shouldAF set to true if you want a mouse scroll to be captured by the component
         */
        "setAutoFocus": (shouldAF: any) => Promise<void>;
        /**
          * Manually supply GO-CAM data to be rendered. This will overwrite any data previously fetched using the gocamId and apiUrl props, if they were provided.
          * @param model GO-CAM object
         */
        "setModelData": (model: any) => Promise<void>;
        /**
          * Show/hide default legend
         */
        "showLegend": boolean;
        "toggleComplex": () => Promise<void>;
    }
    interface GoGocamViewerLegend {
    }
    interface GoGocamViewerSidebar {
        /**
          * BBOP Graph Handler -> GO-CAM Must be provided to build the side panel
         */
        "cam": Cam;
        "highlightActivity": (nodeId: any) => Promise<void>;
        /**
          * Passed by the parent to highlight & clear highlight nodes
         */
        "parentCy": any;
    }
    interface WcLightModal {
        "close": () => Promise<void>;
        "modalAnchor": string;
        "modalContent": string;
        "modalTitle": string;
        "open": () => Promise<void>;
        "toggle": () => Promise<void>;
        "x": number;
        "y": number;
    }
    interface WcSpinner {
        "message": string;
    }
}
export interface GoAnnotationRibbonStripsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGoAnnotationRibbonStripsElement;
}
export interface GoAnnotationRibbonSubjectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGoAnnotationRibbonSubjectElement;
}
export interface GoEntityAutocompleteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGoEntityAutocompleteElement;
}
export interface GoGocamViewerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGoGocamViewerElement;
}
export interface GoGocamViewerSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGoGocamViewerSidebarElement;
}
declare global {
    interface HTMLGoAnnotationRibbonElement extends Components.GoAnnotationRibbon, HTMLStencilElement {
    }
    var HTMLGoAnnotationRibbonElement: {
        prototype: HTMLGoAnnotationRibbonElement;
        new (): HTMLGoAnnotationRibbonElement;
    };
    interface HTMLGoAnnotationRibbonCellElement extends Components.GoAnnotationRibbonCell, HTMLStencilElement {
    }
    var HTMLGoAnnotationRibbonCellElement: {
        prototype: HTMLGoAnnotationRibbonCellElement;
        new (): HTMLGoAnnotationRibbonCellElement;
    };
    interface HTMLGoAnnotationRibbonStripsElementEventMap {
        "cellClick": any;
        "cellEnter": any;
        "cellLeave": any;
        "groupClick": any;
        "groupEnter": any;
        "groupLeave": any;
    }
    interface HTMLGoAnnotationRibbonStripsElement extends Components.GoAnnotationRibbonStrips, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGoAnnotationRibbonStripsElementEventMap>(type: K, listener: (this: HTMLGoAnnotationRibbonStripsElement, ev: GoAnnotationRibbonStripsCustomEvent<HTMLGoAnnotationRibbonStripsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGoAnnotationRibbonStripsElementEventMap>(type: K, listener: (this: HTMLGoAnnotationRibbonStripsElement, ev: GoAnnotationRibbonStripsCustomEvent<HTMLGoAnnotationRibbonStripsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGoAnnotationRibbonStripsElement: {
        prototype: HTMLGoAnnotationRibbonStripsElement;
        new (): HTMLGoAnnotationRibbonStripsElement;
    };
    interface HTMLGoAnnotationRibbonSubjectElementEventMap {
        "subjectClick": any;
    }
    interface HTMLGoAnnotationRibbonSubjectElement extends Components.GoAnnotationRibbonSubject, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGoAnnotationRibbonSubjectElementEventMap>(type: K, listener: (this: HTMLGoAnnotationRibbonSubjectElement, ev: GoAnnotationRibbonSubjectCustomEvent<HTMLGoAnnotationRibbonSubjectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGoAnnotationRibbonSubjectElementEventMap>(type: K, listener: (this: HTMLGoAnnotationRibbonSubjectElement, ev: GoAnnotationRibbonSubjectCustomEvent<HTMLGoAnnotationRibbonSubjectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGoAnnotationRibbonSubjectElement: {
        prototype: HTMLGoAnnotationRibbonSubjectElement;
        new (): HTMLGoAnnotationRibbonSubjectElement;
    };
    interface HTMLGoAnnotationRibbonTableElement extends Components.GoAnnotationRibbonTable, HTMLStencilElement {
    }
    var HTMLGoAnnotationRibbonTableElement: {
        prototype: HTMLGoAnnotationRibbonTableElement;
        new (): HTMLGoAnnotationRibbonTableElement;
    };
    interface HTMLGoEntityAutocompleteElementEventMap {
        "itemSelected": any;
    }
    interface HTMLGoEntityAutocompleteElement extends Components.GoEntityAutocomplete, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGoEntityAutocompleteElementEventMap>(type: K, listener: (this: HTMLGoEntityAutocompleteElement, ev: GoEntityAutocompleteCustomEvent<HTMLGoEntityAutocompleteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGoEntityAutocompleteElementEventMap>(type: K, listener: (this: HTMLGoEntityAutocompleteElement, ev: GoEntityAutocompleteCustomEvent<HTMLGoEntityAutocompleteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGoEntityAutocompleteElement: {
        prototype: HTMLGoEntityAutocompleteElement;
        new (): HTMLGoEntityAutocompleteElement;
    };
    interface HTMLGoGocamViewerElementEventMap {
        "nodeOver": any;
        "nodeOut": any;
        "nodeClick": any;
        "layoutChange": any;
    }
    interface HTMLGoGocamViewerElement extends Components.GoGocamViewer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGoGocamViewerElementEventMap>(type: K, listener: (this: HTMLGoGocamViewerElement, ev: GoGocamViewerCustomEvent<HTMLGoGocamViewerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGoGocamViewerElementEventMap>(type: K, listener: (this: HTMLGoGocamViewerElement, ev: GoGocamViewerCustomEvent<HTMLGoGocamViewerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGoGocamViewerElement: {
        prototype: HTMLGoGocamViewerElement;
        new (): HTMLGoGocamViewerElement;
    };
    interface HTMLGoGocamViewerLegendElement extends Components.GoGocamViewerLegend, HTMLStencilElement {
    }
    var HTMLGoGocamViewerLegendElement: {
        prototype: HTMLGoGocamViewerLegendElement;
        new (): HTMLGoGocamViewerLegendElement;
    };
    interface HTMLGoGocamViewerSidebarElementEventMap {
        "selectChanged": any;
    }
    interface HTMLGoGocamViewerSidebarElement extends Components.GoGocamViewerSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLGoGocamViewerSidebarElementEventMap>(type: K, listener: (this: HTMLGoGocamViewerSidebarElement, ev: GoGocamViewerSidebarCustomEvent<HTMLGoGocamViewerSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLGoGocamViewerSidebarElementEventMap>(type: K, listener: (this: HTMLGoGocamViewerSidebarElement, ev: GoGocamViewerSidebarCustomEvent<HTMLGoGocamViewerSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLGoGocamViewerSidebarElement: {
        prototype: HTMLGoGocamViewerSidebarElement;
        new (): HTMLGoGocamViewerSidebarElement;
    };
    interface HTMLWcLightModalElement extends Components.WcLightModal, HTMLStencilElement {
    }
    var HTMLWcLightModalElement: {
        prototype: HTMLWcLightModalElement;
        new (): HTMLWcLightModalElement;
    };
    interface HTMLWcSpinnerElement extends Components.WcSpinner, HTMLStencilElement {
    }
    var HTMLWcSpinnerElement: {
        prototype: HTMLWcSpinnerElement;
        new (): HTMLWcSpinnerElement;
    };
    interface HTMLElementTagNameMap {
        "go-annotation-ribbon": HTMLGoAnnotationRibbonElement;
        "go-annotation-ribbon-cell": HTMLGoAnnotationRibbonCellElement;
        "go-annotation-ribbon-strips": HTMLGoAnnotationRibbonStripsElement;
        "go-annotation-ribbon-subject": HTMLGoAnnotationRibbonSubjectElement;
        "go-annotation-ribbon-table": HTMLGoAnnotationRibbonTableElement;
        "go-entity-autocomplete": HTMLGoEntityAutocompleteElement;
        "go-gocam-viewer": HTMLGoGocamViewerElement;
        "go-gocam-viewer-legend": HTMLGoGocamViewerLegendElement;
        "go-gocam-viewer-sidebar": HTMLGoGocamViewerSidebarElement;
        "wc-light-modal": HTMLWcLightModalElement;
        "wc-spinner": HTMLWcSpinnerElement;
    }
}
declare namespace LocalJSX {
    interface GoAnnotationRibbon {
        /**
          * add a cell at the beginning of each row/subject to show all annotations
         */
        "addCellAll"?: boolean;
        "annotationLabels"?: string;
        "baseApiUrl"?: string;
        /**
          * false = show a gradient of colors to indicate the value of a cell true = show only two colors (minColor; maxColor) to indicate the values of a cell
         */
        "binaryColor"?: boolean;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryAllStyle"?: number;
        /**
          * Override of the category case 0 (default) = unchanged 1 = to lower case 2 = to upper case
         */
        "categoryCase"?: number;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryOtherStyle"?: number;
        "classLabels"?: string;
        /**
          * Which value to base the cell color on 0 = class count 1 = annotation count
         */
        "colorBy"?: number;
        /**
          * if provided, will override any value provided in subjects and subset
         */
        "data"?: string;
        "excludePB"?: boolean;
        /**
          * Filter rows based on the presence of one or more values in a given column The filtering will be based on cell label or id Example: filter-by="evidence:ISS,ISO or multi-step filters: filter-by:evidence:ISS,ISO;term:xxx" Note: if value is "", remove any filtering
         */
        "filterBy"?: string;
        "filterCrossAspect"?: boolean;
        "filterReference"?: string;
        /**
          * If true, the ribbon will fire an event if a user click an empty cell If false, the ribbon will not fire the event on an empty cell Note: if selectionMode == SELECTION.COLUMN, then the event will trigger if at least one of the selected cells has annotations
         */
        "fireEventOnEmptyCells"?: boolean;
        "groupBaseUrl"?: string;
        /**
          * Using this parameter, the table rows can bee grouped based on column ids A multiple step grouping is possible by using a ";" between groups The grouping applies before the ordering Example: hid-1,hid-3 OR hid-1,hid-3;hid-2 Note: if value is "", remove any grouping
         */
        "groupBy"?: string;
        "groupClickable"?: boolean;
        "groupMaxLabelSize"?: number;
        "groupNewTab"?: boolean;
        /**
          * Used to hide specific column of the table
         */
        "hideColumns"?: string;
        "maxColor"?: string;
        "maxHeatLevel"?: number;
        "minColor"?: string;
        /**
          * This is used to sort the table depending of a column The column cells must be single values The ordering applies after the grouping Note: if value is "", remove any ordering
         */
        "orderBy"?: string;
        /**
          * If no value is provided, the ribbon will load without any group selected. If a value is provided, the ribbon will show the requested group as selected The value should be the id of the group to be selected
         */
        "selected"?: any;
        /**
          * Click handling of a cell. 0 = select only the cell (1 subject, 1 group) 1 = select the whole column (all subjects, 1 group)
         */
        "selectionMode"?: number;
        /**
          * add a cell at the end of each row/subject to represent all annotations not mapped to a specific term
         */
        "showOtherGroup"?: boolean;
        "subjectBaseUrl"?: string;
        "subjectOpenNewTab"?: boolean;
        /**
          * Position the subject label of each row 0 = None 1 = Left 2 = Right 3 = Bottom
         */
        "subjectPosition"?: number;
        "subjectUseTaxonIcon"?: boolean;
        /**
          * provide gene ids (e.g. RGD:620474,RGD:3889 or as a list ["RGD:620474", "RGD:3889"])
         */
        "subjects"?: string;
        "subset"?: string;
    }
    interface GoAnnotationRibbonCell {
        "annotationLabels"?: string;
        /**
          * If set to true, won't show any color and can not be hovered or selected This is used for group that can not have annotation for a given subject
         */
        "available"?: boolean;
        "binaryColor"?: boolean;
        "classLabels"?: string;
        "colorBy"?: number;
        "group"?: IRibbonGroup;
        "hovered"?: boolean;
        "maxColor"?: string;
        "maxHeatLevel"?: number;
        "minColor"?: string;
        "selected"?: boolean;
        "subject"?: IRibbonSubject;
    }
    interface GoAnnotationRibbonStrips {
        /**
          * add a cell at the beginning of each row/subject to show all annotations
         */
        "addCellAll"?: boolean;
        "annotationLabels"?: string;
        "baseApiUrl"?: string;
        /**
          * false = show a gradient of colors to indicate the value of a cell true = show only two colors (minColor; maxColor) to indicate the values of a cell
         */
        "binaryColor"?: boolean;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryAllStyle"?: number;
        /**
          * Override of the category case 0 (default) = unchanged 1 = to lower case 2 = to upper case
         */
        "categoryCase"?: number;
        /**
          * 0 = Normal 1 = Bold
         */
        "categoryOtherStyle"?: number;
        "classLabels"?: string;
        /**
          * Which value to base the cell color on 0 = class count 1 = annotation count
         */
        "colorBy"?: number;
        /**
          * if provided, will override any value provided in subjects and subset
         */
        "data"?: string;
        /**
          * If true, the ribbon will fire an event if a user click an empty cell If false, the ribbon will not fire the event on an empty cell Note: if selectionMode == SELECTION.COLUMN, then the event will trigger if at least one of the selected cells has annotations
         */
        "fireEventOnEmptyCells"?: boolean;
        "groupBaseUrl"?: string;
        "groupClickable"?: boolean;
        "groupMaxLabelSize"?: number;
        "groupNewTab"?: boolean;
        "maxColor"?: string;
        "maxHeatLevel"?: number;
        "minColor"?: string;
        /**
          * This event is triggered whenever a ribbon cell is clicked
         */
        "onCellClick"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        /**
          * This event is triggered whenever the mouse enters a cell area
         */
        "onCellEnter"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        /**
          * This event is triggered whenever the mouse leaves a cell area
         */
        "onCellLeave"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        /**
          * This event is triggered whenever a group cell is clicked
         */
        "onGroupClick"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        /**
          * This event is triggered whenever the mouse enters a group cell area
         */
        "onGroupEnter"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        /**
          * This event is triggered whenever the mouse leaves a group cell area
         */
        "onGroupLeave"?: (event: GoAnnotationRibbonStripsCustomEvent<any>) => void;
        "ribbonSummary"?: IRibbonModel;
        /**
          * If no value is provided, the ribbon will load without any group selected. If a value is provided, the ribbon will show the requested group as selected The value should be the id of the group to be selected
         */
        "selected"?: any;
        /**
          * Click handling of a cell. 0 = select only the cell (1 subject, 1 group) 1 = select the whole column (all subjects, 1 group)
         */
        "selectionMode"?: number;
        "showOtherGroup"?: boolean;
        "subjectBaseUrl"?: string;
        "subjectOpenNewTab"?: boolean;
        /**
          * Position the subject label of each row 0 = None 1 = Left 2 = Right 3 = Bottom
         */
        "subjectPosition"?: number;
        "subjectUseTaxonIcon"?: boolean;
        /**
          * provide gene ids (e.g. RGD:620474,RGD:3889 or as a list ["RGD:620474", "RGD:3889"])
         */
        "subjects"?: string;
        "subset"?: string;
        /**
          * When this is set to false, changing the subjects Prop won't trigger the reload of the ribbon This is necessary when the ribbon is showing data other than GO or not using the internal fetchData mechanism
         */
        "updateOnSubjectChange"?: boolean;
    }
    interface GoAnnotationRibbonSubject {
        "newTab"?: boolean;
        /**
          * This event is triggered whenever a subject label is clicked Can call preventDefault() to avoid the default behavior (opening the linked subject page)
         */
        "onSubjectClick"?: (event: GoAnnotationRibbonSubjectCustomEvent<any>) => void;
        "subject"?: IRibbonSubject;
        "subjectBaseURL"?: string;
    }
    interface GoAnnotationRibbonTable {
        "baseApiUrl"?: string;
        /**
          * Reading biolink data. This will trigger a render of the table as would changing data
         */
        "bioLinkData"?: string;
        /**
          * Must follow the appropriate JSON data model Can be given as either JSON or stringified JSON
         */
        "data"?: string;
        /**
          * Filter rows based on the presence of one or more values in a given column The filtering will be based on cell label or id Example: filter-by="evidence:ISS,ISO or multi-step filters: filter-by:evidence:ISS,ISO;term:xxx" Note: if value is "", remove any filtering
         */
        "filterBy"?: string;
        "groupBaseUrl"?: string;
        /**
          * Using this parameter, the table rows can bee grouped based on column ids A multiple step grouping is possible by using a ";" between groups The grouping applies before the ordering Example: hid-1,hid-3 OR hid-1,hid-3;hid-2 Note: if value is "", remove any grouping
         */
        "groupBy"?: string;
        /**
          * Used to hide specific column of the table
         */
        "hideColumns"?: string;
        /**
          * This is used to sort the table depending of a column The column cells must be single values The ordering applies after the grouping Note: if value is "", remove any ordering
         */
        "orderBy"?: string;
        "subjectBaseUrl"?: string;
    }
    interface GoEntityAutocomplete {
        /**
          * Category to constrain the search; by default search "gene" Other values accepted: `undefined` : search both terms and genes `gene` : will only search genes used in GO `biological%20process` : will search for GO BP terms `molecular%20function` : will search for GO MF terms `cellular%20component` : will search for GO CC terms `cellular%20component,molecular%20function,biological%20process` : will search any GO term
         */
        "category"?: string;
        /**
          * Maximum number of results to show
         */
        "maxResults"?: number;
        /**
          * Event triggered whenever an item is selected from the autocomplete
         */
        "onItemSelected"?: (event: GoEntityAutocompleteCustomEvent<any>) => void;
        /**
          * Default placeholder for the autocomplete
         */
        "placeholder"?: string;
        "value"?: string;
    }
    interface GoGocamViewer {
        /**
          * The url used to fetch GO-CAM graphs. Any occurrence of %ID in the string will be replaced by the GO-CAM ID.
         */
        "apiUrl"?: string;
        /**
          * ID of the GO-CAM to be shown in this widget. If provided, the GO-CAM will automatically be fetched using this ID and the value of the `api-url` prop. If omitted, data will not automatically be fetched, but can be provided via the `setModelData` method. This may be useful if the host page already has the GO-CAM data.
         */
        "gocamId"?: string;
        "onLayoutChange"?: (event: GoGocamViewerCustomEvent<any>) => void;
        "onNodeClick"?: (event: GoGocamViewerCustomEvent<any>) => void;
        "onNodeOut"?: (event: GoGocamViewerCustomEvent<any>) => void;
        "onNodeOver"?: (event: GoGocamViewerCustomEvent<any>) => void;
        /**
          * Show/hide default legend
         */
        "showLegend"?: boolean;
    }
    interface GoGocamViewerLegend {
    }
    interface GoGocamViewerSidebar {
        /**
          * BBOP Graph Handler -> GO-CAM Must be provided to build the side panel
         */
        "cam"?: Cam;
        "onSelectChanged"?: (event: GoGocamViewerSidebarCustomEvent<any>) => void;
        /**
          * Passed by the parent to highlight & clear highlight nodes
         */
        "parentCy"?: any;
    }
    interface WcLightModal {
        "modalAnchor"?: string;
        "modalContent"?: string;
        "modalTitle"?: string;
        "x"?: number;
        "y"?: number;
    }
    interface WcSpinner {
        "message"?: string;
    }
    interface IntrinsicElements {
        "go-annotation-ribbon": GoAnnotationRibbon;
        "go-annotation-ribbon-cell": GoAnnotationRibbonCell;
        "go-annotation-ribbon-strips": GoAnnotationRibbonStrips;
        "go-annotation-ribbon-subject": GoAnnotationRibbonSubject;
        "go-annotation-ribbon-table": GoAnnotationRibbonTable;
        "go-entity-autocomplete": GoEntityAutocomplete;
        "go-gocam-viewer": GoGocamViewer;
        "go-gocam-viewer-legend": GoGocamViewerLegend;
        "go-gocam-viewer-sidebar": GoGocamViewerSidebar;
        "wc-light-modal": WcLightModal;
        "wc-spinner": WcSpinner;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "go-annotation-ribbon": LocalJSX.GoAnnotationRibbon & JSXBase.HTMLAttributes<HTMLGoAnnotationRibbonElement>;
            "go-annotation-ribbon-cell": LocalJSX.GoAnnotationRibbonCell & JSXBase.HTMLAttributes<HTMLGoAnnotationRibbonCellElement>;
            "go-annotation-ribbon-strips": LocalJSX.GoAnnotationRibbonStrips & JSXBase.HTMLAttributes<HTMLGoAnnotationRibbonStripsElement>;
            "go-annotation-ribbon-subject": LocalJSX.GoAnnotationRibbonSubject & JSXBase.HTMLAttributes<HTMLGoAnnotationRibbonSubjectElement>;
            "go-annotation-ribbon-table": LocalJSX.GoAnnotationRibbonTable & JSXBase.HTMLAttributes<HTMLGoAnnotationRibbonTableElement>;
            "go-entity-autocomplete": LocalJSX.GoEntityAutocomplete & JSXBase.HTMLAttributes<HTMLGoEntityAutocompleteElement>;
            "go-gocam-viewer": LocalJSX.GoGocamViewer & JSXBase.HTMLAttributes<HTMLGoGocamViewerElement>;
            "go-gocam-viewer-legend": LocalJSX.GoGocamViewerLegend & JSXBase.HTMLAttributes<HTMLGoGocamViewerLegendElement>;
            "go-gocam-viewer-sidebar": LocalJSX.GoGocamViewerSidebar & JSXBase.HTMLAttributes<HTMLGoGocamViewerSidebarElement>;
            "wc-light-modal": LocalJSX.WcLightModal & JSXBase.HTMLAttributes<HTMLWcLightModalElement>;
            "wc-spinner": LocalJSX.WcSpinner & JSXBase.HTMLAttributes<HTMLWcSpinnerElement>;
        }
    }
}
